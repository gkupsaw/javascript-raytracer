[{"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/index.js":"1","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/App.js":"2","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/auto/reportWebVitals.js":"3","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/index.js":"4","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/parser/scene-parser.js":"5","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/lib/index.js":"6","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/parser/constants.js":"7","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/raytracing/RayScene.js":"8","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/raytracing/LightingUtils.js":"9","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/raytracing/ImplicitShapes.js":"10","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/raytracing/Camera.js":"11","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/raytracing/ImplicitShapes.tests.js":"12","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/lib/glm.js":"13","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/lib/datatypes.js":"14","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/lib/mathjsUtils.js":"15","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/lib/extendMatrixUtils.js":"16"},{"size":525,"mtime":1611447832679,"results":"17","hashOfConfig":"18"},{"size":527,"mtime":1611561726224,"results":"19","hashOfConfig":"18"},{"size":362,"mtime":1611447764692,"results":"20","hashOfConfig":"18"},{"size":3180,"mtime":1611615581060,"results":"21","hashOfConfig":"18"},{"size":8602,"mtime":1611603909591,"results":"22","hashOfConfig":"18"},{"size":159,"mtime":1611601812104,"results":"23","hashOfConfig":"18"},{"size":1286,"mtime":1611604605865,"results":"24","hashOfConfig":"18"},{"size":10790,"mtime":1611615857648,"results":"25","hashOfConfig":"18"},{"size":1133,"mtime":1611604583334,"results":"26","hashOfConfig":"18"},{"size":6357,"mtime":1611561661813,"results":"27","hashOfConfig":"18"},{"size":5347,"mtime":1611602682816,"results":"28","hashOfConfig":"18"},{"size":741,"mtime":1611561709032,"results":"29","hashOfConfig":"18"},{"size":3103,"mtime":1611604134070,"results":"30","hashOfConfig":"18"},{"size":2871,"mtime":1611599712754,"results":"31","hashOfConfig":"18"},{"size":122,"mtime":1611560339421,"results":"32","hashOfConfig":"18"},{"size":1089,"mtime":1611604876503,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"13j71y1",{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"43","messages":"44","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"36"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"36"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"61","messages":"62","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"36"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/index.js",[],["70","71"],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/App.js",[],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/auto/reportWebVitals.js",[],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/index.js",["72","73"],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/parser/scene-parser.js",["74"],"import {\n    vec3,\n    vec4,\n    RGBA,\n    GlobalData,\n    LightData,\n    ShapeData,\n    lightTypes,\n    Primitive,\n    Material,\n    mat_inv,\n    translate,\n    scale,\n    rotate,\n    id4,\n} from '../lib';\nimport {\n    defaultData,\n    GLOBAL,\n    LIGHT,\n    CAMERA,\n    TRANSBLOCK,\n    OBJECT,\n    tagnames,\n} from './constants';\n\nlet instantiatedObjects = {}; // TODO: make this non-global\n\nconst parseFloatAttr = (xmlEl, attr) => parseFloat(xmlEl.getAttribute(attr));\n\nconst getVec3 = (xmlEl) =>\n    vec3(\n        parseFloatAttr(xmlEl, 'x'),\n        parseFloatAttr(xmlEl, 'y'),\n        parseFloatAttr(xmlEl, 'z')\n    );\nconst getPosition = (xmlEl) =>\n    vec4(\n        parseFloatAttr(xmlEl, 'x'),\n        parseFloatAttr(xmlEl, 'y'),\n        parseFloatAttr(xmlEl, 'z'),\n        1\n    );\nconst getDirection = (xmlEl) =>\n    vec4(\n        parseFloatAttr(xmlEl, 'x'),\n        parseFloatAttr(xmlEl, 'y'),\n        parseFloatAttr(xmlEl, 'z'),\n        0\n    );\nconst getRGBA = (xmlEl) =>\n    vec4(\n        // new RGBA\n        parseFloatAttr(xmlEl, 'r'),\n        parseFloatAttr(xmlEl, 'g'),\n        parseFloatAttr(xmlEl, 'b'),\n        1\n    );\n\nconst parseGlobal = (global) => {\n    let globalData = new GlobalData({ ...defaultData.global });\n\n    for (const datum of global.children) {\n        let propName, propVal;\n        switch (datum.tagName) {\n            case tagnames.global.DIFFUSE:\n                propName = 'kd';\n                propVal = datum.getAttribute('v');\n                break;\n            case tagnames.global.SPECULAR:\n                propName = 'ks';\n                propVal = datum.getAttribute('v');\n                break;\n            case tagnames.global.AMBIENT:\n                propName = 'ka';\n                propVal = datum.getAttribute('v');\n                break;\n            default:\n                console.error(`Unknown global data tag: ${datum.tagName}`);\n                break;\n        }\n        if (propName) {\n            globalData[propName] = propVal;\n        }\n    }\n\n    return globalData;\n};\n\nconst parseCamera = (camera) => {\n    let cameraData = {};\n\n    for (const attr of camera.children) {\n        switch (attr.tagName) {\n            case tagnames.camera.POS:\n                cameraData['pos'] = getPosition(attr);\n                break;\n            case tagnames.camera.UP:\n                cameraData['up'] = getDirection(attr);\n                break;\n            default:\n                console.error(`Unknown camera data tag: ${attr.tagName}`);\n                break;\n        }\n    }\n\n    return cameraData;\n};\n\nconst parseLight = (light) => {\n    let lightData = new LightData({\n        type: lightTypes.POINT,\n        func: vec3(1, 0, 0),\n    });\n\n    for (const attr of light.children) {\n        let propName, propVal;\n        switch (attr.tagName) {\n            case tagnames.light.ID:\n                propName = 'id';\n                propVal = attr.getAttribute('v');\n                break;\n            case tagnames.light.COLOR:\n                propName = 'color';\n                propVal = getRGBA(attr);\n                break;\n            case tagnames.light.POS:\n                propName = 'pos';\n                propVal = getPosition(attr);\n                break;\n            default:\n                console.error(`Unknown light data tag: ${attr.tagName}`);\n                break;\n        }\n        if (propName) {\n            lightData[propName] = propVal;\n        }\n    }\n\n    return lightData;\n};\n\nconst parseObject = (object, transformation = id4()) => {\n    const name = object.getAttribute('name');\n    const type = object.getAttribute('type');\n    let objects = [];\n\n    switch (type) {\n        case 'primitive':\n            let material = new Material({ ...defaultData.material });\n\n            for (const attr of object.children) {\n                switch (attr.tagName) {\n                    case tagnames.object.DIFFUSE:\n                        material.setDiffuse(getRGBA(attr));\n                        break;\n                    case tagnames.object.SPECULAR:\n                        material.setSpecular(getRGBA(attr));\n                        break;\n                    case tagnames.object.AMBIENT:\n                        material.setAmbient(getRGBA(attr));\n                        break;\n                    default:\n                        console.error(\n                            `Unknown primitive object data tag: ${attr.tagName}`\n                        );\n                        break;\n                }\n            }\n\n            const primitive = new Primitive({ type: name, material });\n            const inverseTransformation = mat_inv(transformation);\n            const objectData = new ShapeData({\n                primitive,\n                transformation,\n                inverseTransformation,\n            });\n\n            if (!instantiatedObjects[name]) {\n                instantiatedObjects[name] = objectData;\n            }\n\n            objects.push(objectData);\n            break;\n        case 'tree':\n            for (const attr of object.children) {\n                switch (attr.tagName) {\n                    case TRANSBLOCK:\n                        for (const treeChild of attr.children) {\n                            switch (treeChild.tagName) {\n                                case tagnames.transblock.TRANSLATE:\n                                    transformation = translate(\n                                        transformation,\n                                        getVec3(treeChild)\n                                    );\n                                    break;\n                                case tagnames.transblock.ROTATE:\n                                    transformation = rotate(\n                                        transformation,\n                                        treeChild.getAttribute('angle'),\n                                        getVec3(treeChild)\n                                    );\n                                    break;\n                                case tagnames.transblock.SCALE:\n                                    transformation = scale(\n                                        transformation,\n                                        getVec3(treeChild)\n                                    );\n                                    break;\n                                case OBJECT:\n                                    objects = objects.concat(\n                                        parseObject(treeChild, transformation)\n                                    );\n                                    break;\n                                default:\n                                    console.error(\n                                        `Unknown treeChild data tag: ${treeChild.tagName}`\n                                    );\n                            }\n                        }\n                        break;\n                    case OBJECT:\n                        objects.push(parseObject(attr, transformation));\n                        break;\n                    default:\n                        console.error(\n                            `Unknown root object data tag: ${attr.tagName}`\n                        );\n                        break;\n                }\n            }\n            break;\n        case 'instance':\n            objects.push(new ShapeData({ ...instantiatedObjects[name] }));\n            break;\n        default:\n            console.error(`Unknown object type tag: ${type}`);\n            break;\n    }\n\n    return objects;\n};\n\nconst parse = (scene) => {\n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(scene, 'text/xml');\n\n    let data = { ...defaultData };\n\n    const scenefile = xmlDoc.getElementsByTagName('scenefile')[0];\n\n    let child = scenefile.firstElementChild;\n    while (child) {\n        switch (child.tagName) {\n            case GLOBAL:\n                data.global = parseGlobal(child);\n                break;\n            case LIGHT:\n                data.light.push(parseLight(child));\n                break;\n            case CAMERA:\n                data.camera = parseCamera(child);\n                break;\n            case OBJECT:\n                data.object = data.object.concat(parseObject(child));\n                break;\n            default:\n                console.error(`Unknown root child tag: ${child.tagName}`);\n                break;\n        }\n\n        child = child.nextElementSibling;\n    }\n\n    return data;\n};\n\nconst main = (scenefilePath) => {\n    const scene = null;\n    const scenegraph = parse(scene);\n    return scenegraph;\n};\n\nexport { parse, main };\n","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/lib/index.js",[],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/parser/constants.js",["75"],"import { RGBA, vec4 } from '../lib';\n\nconst defaultData = {\n    global: { ka: 1, kd: 1, ks: 1 },\n    camera: {\n        pos: vec4(5, 5, 5, 1),\n        up: vec4(0, 1, 0, 0),\n        look: vec4(-1, -1, -1, 0),\n        heightAngle: 45,\n        aspectRatio: 1,\n    },\n    light: [],\n    object: [],\n\n    material: {\n        cDiffuse: vec4(0.5, 0.5, 0.5, 1), // new RGBA\n        cAmbient: vec4(0.5, 0.5, 0.5, 1), // new RGBA\n        cSpecular: vec4(0.5, 0.5, 0.5, 1), // new RGBA\n        cReflective: vec4(1, 1, 1, 1), // new RGBA\n        shininess: 0.5,\n    },\n};\n\nconst GLOBAL = 'globaldata';\nconst LIGHT = 'lightdata';\nconst CAMERA = 'cameradata';\nconst TRANSBLOCK = 'transblock';\nconst OBJECT = 'object';\n\nconst tagnames = {\n    global: {\n        DIFFUSE: 'diffusecoeff',\n        SPECULAR: 'specularcoeff',\n        AMBIENT: 'ambientcoeff',\n    },\n    light: {\n        ID: 'id',\n        COLOR: 'color',\n        POS: 'position',\n    },\n    camera: {\n        POS: 'pos',\n        UP: 'up',\n    },\n    object: {\n        DIFFUSE: 'diffuse',\n        SPECULAR: 'specular',\n        AMBIENT: 'ambient',\n    },\n    transblock: {\n        TRANSLATE: 'translate',\n        SCALE: 'scale',\n        ROTATE: 'rotate',\n    },\n};\n\nexport { defaultData, GLOBAL, LIGHT, CAMERA, TRANSBLOCK, OBJECT, tagnames };\n","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/raytracing/RayScene.js",["76","77","78"],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/raytracing/LightingUtils.js",[],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/raytracing/ImplicitShapes.js",[],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/raytracing/Camera.js",[],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/raytracing/ImplicitShapes.tests.js",[],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/lib/glm.js",["79","80"],"import {\n    dot,\n    cross,\n    det,\n    inv,\n    transpose as mat_transpose,\n    multiply,\n    matrix,\n    index,\n    subset,\n} from 'mathjs';\nconst { sin, cos, tan, atan } = Math;\n\nconst normalize = (vec) => {\n    let sqrSum = 0;\n\n    vec.forEach((val) => (sqrSum += Math.pow(val, 2)));\n\n    const magnitude = Math.sqrt(sqrSum);\n\n    return multiply(vec, 1 / magnitude);\n};\n\nconst translate = (M, x) => {\n    const dim = parseInt(M.size()[1]);\n    const maxDim = dim - 1;\n    let indices = [],\n        replacements = [];\n\n    for (let i = 0; i < maxDim; i++) {\n        indices.push(i);\n        replacements.push(subset(M, index(i, maxDim)) - subset(x, index(i)));\n    }\n\n    M = subset(M, index(indices, maxDim), replacements);\n    return M;\n};\nconst scale = (M, x) => {\n    const dim = parseInt(M.size()[1]);\n    const maxDim = dim - 1;\n\n    for (let i = 0; i < maxDim; i++) {\n        M = subset(\n            M,\n            index(i, i),\n            subset(M, index(i, i)) * subset(x, index(i))\n        ); // is this less efficient?\n    }\n\n    return M;\n};\nconst rotate = (M, x, a) => {\n    console.error('No rotate!');\n    return M;\n};\nconst mat_inv = (M) => {\n    if (det(M) === 0) {\n        console.error(M);\n        return M;\n        //id4();\n    } else {\n        return inv(M);\n    }\n};\nconst radians = (deg) => (deg * Math.PI) / 180;\nconst degrees = (rad) => (180 * rad) / Math.PI;\nconst clamp = (v, min = 0, max = 1) => {\n    if (isNaN(v)) {\n        return v.map((value) => {\n            return Math.max(Math.min(value, max), min);\n        });\n    }\n    return Math.max(Math.min(v, max), min);\n};\n\nconst mat3 = (row1, row2, row3) => {\n    if (row1 && row2 === undefined && row3 === undefined) {\n        const mat4ToShrink = row1.clone();\n        mat4ToShrink.resize([3, 3]);\n        return mat4ToShrink;\n    }\n    return matrix([row1, row2, row3]);\n};\n\nconst mat4x4 = (row1, row2, row3, row4) => matrix([row1, row2, row3, row4]);\n\nconst vec3 = (x, y, z) => {\n    let vec;\n\n    if (y === undefined && z === undefined) {\n        vec = matrix([x, x, x]);\n    } else {\n        vec = matrix([x, y, z]);\n    }\n\n    return vec;\n};\n\nconst vec4 = (x, y, z, w) => {\n    let vec;\n\n    if (y === undefined && z === undefined && w === undefined) {\n        vec = matrix([x, x, x, x]);\n    } else if (z === undefined && w === undefined) {\n        vec = x.clone();\n        vec.resize([4], y);\n    } else {\n        vec = matrix([x, y, z, w]);\n    }\n\n    return vec;\n};\n\nconst id4 = () =>\n    matrix([\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ]);\n\nconst tests = () => {\n    const M = id4();\n    const x = vec3(1, 2, 3);\n\n    const translateSuccess =\n        translate(M, x) ===\n        matrix([\n            [1, 0, 0, -1],\n            [0, 1, 0, -2],\n            [0, 0, 1, -3],\n            [0, 0, 0, 1],\n        ]);\n};\n\nexport {\n    clamp,\n    normalize,\n    dot,\n    cross,\n    mat_inv,\n    mat_transpose,\n    translate,\n    scale,\n    rotate,\n    sin,\n    cos,\n    tan,\n    atan,\n    radians,\n    degrees,\n    vec3,\n    vec4,\n    mat3,\n    mat4x4,\n    id4,\n};\n","/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/lib/datatypes.js",[],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/lib/mathjsUtils.js",[],"/Users/griffinkupsaw/Documents/mini projects/html-projects/raytracer/src/utils/lib/extendMatrixUtils.js",[],{"ruleId":"81","replacedBy":"82"},{"ruleId":"83","replacedBy":"84"},{"ruleId":"85","severity":1,"message":"86","line":4,"column":10,"nodeType":"87","messageId":"88","endLine":4,"endColumn":16},{"ruleId":"85","severity":1,"message":"89","line":4,"column":18,"nodeType":"87","messageId":"88","endLine":4,"endColumn":22},{"ruleId":"85","severity":1,"message":"90","line":4,"column":5,"nodeType":"87","messageId":"88","endLine":4,"endColumn":9},{"ruleId":"85","severity":1,"message":"90","line":1,"column":10,"nodeType":"87","messageId":"88","endLine":1,"endColumn":14},{"ruleId":"85","severity":1,"message":"90","line":4,"column":5,"nodeType":"87","messageId":"88","endLine":4,"endColumn":9},{"ruleId":"85","severity":1,"message":"91","line":15,"column":5,"nodeType":"87","messageId":"88","endLine":15,"endColumn":10},{"ruleId":"85","severity":1,"message":"92","line":16,"column":5,"nodeType":"87","messageId":"88","endLine":16,"endColumn":8},{"ruleId":"85","severity":1,"message":"93","line":122,"column":7,"nodeType":"87","messageId":"88","endLine":122,"endColumn":12},{"ruleId":"85","severity":1,"message":"94","line":126,"column":11,"nodeType":"87","messageId":"88","endLine":126,"endColumn":27},"no-native-reassign",["95"],"no-negated-in-lhs",["96"],"no-unused-vars","'matrix' is defined but never used.","Identifier","unusedVar","'vec4' is defined but never used.","'RGBA' is defined but never used.","'chain' is defined but never used.","'id4' is defined but never used.","'tests' is assigned a value but never used.","'translateSuccess' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]